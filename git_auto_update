#!/usr/bin/perl
use Cwd 'abs_path';
use File::Basename;

$debug = 0;
$originRepo = "https://github.com/mredig/autoUpdateTest.git";
$cronTimer = "* * * * *"; ## r0-59 means random 0-59

## dynamic
$projectName = "";
$thisScript = &getExecutableName;
$thisDir = &getExecutableDirectory;

&main;

sub main {
	&processArguments;
}

sub processArguments {
	$processedArgument = 0;
	my %processedArguments;
	for (my $i = 0; $i < scalar(@ARGV); $i++) {
		my $arg = $ARGV[$i];
		if ($arg =~ /^-(\w)/) {
			$arg = $1;
			my ($key, $value) = &processArgument($arg, $ARGV[$i + 1]);
			$processedArguments{$key} = $value;
		}
	}
	if ($processedArgument == 0) {
		die "Usage: git_auto_update [options]\n";
	}
	if ($processedArguments{'debug'} == 1) {
		$debug = 1;
	}

	if ($processedArguments{'install'} == 1) {
		## start install here
		&printIntro;
		&cloneGit;
		&deriveProjectName;
		&setupUpdateChecks;
		&deployCleanup;
	} elsif ($processedArguments{'update'} == 1) {
		## start update here
		&chdirToRepo;
		&runPreflightScript;
		&gitPull;
		&runPostflightScript;
	}
}

sub processArgument {
	my $arg = $_[0];
	my $nextArg = $_[1];
	my $key, $value;
	if ($arg eq "u") {
		$processedArgument = 1;
		$key = "update";
		$value = 1;
	} elsif ($arg eq "d") {
		print "Debug mode\n";
		$key = "debug";
		$value = 1;
	} elsif ($arg eq "i") {
		$processedArgument = 1;
		print "Install/Deploy mode\n";
		$key = "install";
		$value = 1;
	}
	return ($key, $value);
}

## UPGRADE / GIT PULL

sub chdirToRepo {
	chdir "$thisDir";
}

sub runPreflightScript {
	if (-e "Scripts/preflight") {
		my $fullPreflightPath = abs_path("./Scripts/preflight");
		&runOnSystem($fullPreflightPath);
	}
}

sub gitPull {
	## also update submodules
	&runOnSystem("git pull");
	&runOnSystem("git submodule update --init --recursive")
}

sub runPostflightScript {
	if (-e "Scripts/postflight") {
		my $fullPostflightPath = abs_path("./Scripts/postflight");
		&runOnSystem($fullPostflightPath);
	}
}

## INSTALL AND DEPLOY

sub printIntro {
	my $answer = &checkyN("Please confirm you want to install into the directory '$thisDir'");
	if ($answer == 0) {
		die "Please move the installer into the directory you want to install into.\n";
	}
	my $thisUser = getlogin;
	my $userAnswer = &checkyN("Please confirm you want to install this into $thisUser" . "'s crontab");
	if ($userAnswer == 0) {
		die "Please run the installer as the user you want it to run as.\n";
	}
}

sub cloneGit {
	if ($originRepo eq "") {
		print "Please enter the repository link:";
		chomp($originRepo = <STDIN>);
	}
	chdir $thisDir;
	&runOnSystem("git clone $originRepo");
	&runOnSystem("git submodule update --init --recursive")
}

sub setupUpdateChecks {
	my $newCron = &calculateCronTimer;
	my $cronEntry = "$newCron $thisDir/$projectName/$thisScript";
	my $previousCron = `crontab -l`;
	my $newCron = "$previousCron\n$cronEntry\n";
	print "$cronSetCommand\n";
	if ($debug) {
		print "new Cron:\n\n";
		print "$newCron\n";
	} else {
		open my $cronFH, "| crontab -" or die "can't open crontab: $!"; ## reference: https://stackoverflow.com/questions/18133498/how-to-use-perl-to-modify-crontab
		print $cronFH "$newCron";
		close $cronFH;
		print "updated crontab with new entry:\n$cronEntry\n";
	}
}

sub calculateCronTimer {
	my $newCron = $cronTimer;
	while($newCron =~ /r(\d+)-(\d+)/) {
		my $ranString = "r$1-$2";
		my $lowRan = $1;
		my $hiRan = $2;
		my $range = $hiRan - $lowRan;
		my $rand = int(rand($range));
		$rand += $lowRan;
		$newCron =~ s/$ranString/$rand/;
	}
	return $newCron;
}

sub deriveProjectName {
	$projectName = basename($originRepo);
	$projectName =~ s/\.git$//;
}

sub deployCleanup {
	my $fullExecPath = abs_path($0);
	my $delete = &checkYn("Delete installer '$fullExecPath'?");
	if ($delete && $debug == 0) {
		unlink $fullExecPath;
	}

}

## support subroutines

sub runOnSystem { ## executes system command and communicates to user what it's doing - be sure to be careful of arbitrary code execution
	my $command = $_[0];
	if ($debug) {
		print "debug: $command\n";
	} else {
		print "\n\n[[executing: $command]]\n\n";
		system("$command");
	}
}

sub getExecutableDirectory {
	my $fullPath = abs_path($0);
	my $dirname  = dirname($fullPath);
	return $dirname;
}

sub getExecutableName {
	my $name = basename($0);
	return $name;
}

sub checkyN { ## provided a prompt, will ask user how to proceed, assuming NO and else opting yes
	my $prompt = $_[0] . " [y/N]:";
	print "$prompt";
	my $rVal = -1;
	while($rVal == -1) {
		chomp(my $yn = <STDIN>);
		if ($yn =~ /^y+$/i) {
		 	$rVal = 1;
		} elsif ($yn =~ /^n*$/i) {
			$rVal = 0;
		} else {
			print "Sorry, that's not valid input. Please try again:\n\n$prompt";
		}
	}
	return $rVal;
}

sub checkYn { ## provided a prompt, will ask user how to proceed, assuming YES and else opting no
	my $prompt = $_[0] . " [Y/n]:";
	print "$prompt";
	my $rVal = -1;
	while($rVal == -1) {
		chomp(my $yn = <STDIN>);
		if ($yn =~ /^y*$/i) {
		 	$rVal = 1;
		} elsif ($yn =~ /^n+$/i) {
			$rVal = 0;
		} else {
			print "Sorry, that's not valid input. Please try again:\n\n$prompt";
		}
	}
	return $rVal;
}
